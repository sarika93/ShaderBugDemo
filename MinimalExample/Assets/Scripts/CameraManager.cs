using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;

// This component should be attached to a GameObject with a Camera component.
public class CameraManager : MonoBehaviour {
  public Shader DepthShader;
  public float ImageSaveFrequencyHz;
  public string ImageSavePath;
  private float _imageSavePeriodSeconds;
  private uint _saveCount = 0;
  private DateTime _lastSaveTime;
  private Camera _cam;
  private int _imageWidth;
  private int _imageHeight;
  // Stores RGB images generated by camera shader.
  private RenderTexture _colorRenderTexture;
  private RenderTexture _depthRenderTexture;
  private Texture2D _colorSnapshotTexture;
  private Texture2D _depthSnapshotTexture;
  private RenderBuffer[] _renderBuffers;

  private void Start() {
    // Creating image save path if not found
    if (!Directory.Exists(ImageSavePath))
        Directory.CreateDirectory(ImageSavePath);

    // For testing purposes, so not accouting for window resizing.
    _cam = GetComponent<Camera>();
    _imageHeight = _cam.pixelHeight;
    _imageWidth = _cam.pixelWidth;

    // Initialising textures and Camera for rendering
    _colorRenderTexture = new RenderTexture(_imageWidth, _imageHeight, 24, RenderTextureFormat.ARGB32);
    _colorRenderTexture.enableRandomWrite = true;   // Needed, since this will be read from a ComputeShader.
    _colorRenderTexture.Create();

    // Normally RFloat (see comment), but this cannot be used with ReadPixels so for demo purposes,
    // using a different format.
    //_depthRenderTexture = new RenderTexture(_imageWidth, _imageHeight, 0, RenderTextureFormat.RFloat);
    _depthRenderTexture = new RenderTexture(_imageWidth, _imageHeight, 0, RenderTextureFormat.ARGB32);
    _depthRenderTexture.enableRandomWrite = true;   // Needed, since this will be read from a ComputeShader.
    _depthRenderTexture.Create();

    _colorSnapshotTexture = new Texture2D(_imageWidth, _imageHeight, TextureFormat.RGBA32, false);
    //_depthSnapshotTexture = new Texture2D(_imageWidth, _imageHeight, TextureFormat.RFloat, false);
    _depthSnapshotTexture = new Texture2D(_imageWidth, _imageHeight, TextureFormat.RGBA32, false);

    _renderBuffers = new RenderBuffer[2] { _colorRenderTexture.colorBuffer, _depthRenderTexture.colorBuffer };
    _cam.SetTargetBuffers(_renderBuffers, _colorRenderTexture.depthBuffer);
    _cam.depthTextureMode = DepthTextureMode.Depth; // Ensure that the camera generates a depth buffer.
    _cam.SetReplacementShader(DepthShader, "RenderType");
    _cam.enabled = false;
    _lastSaveTime = DateTime.Now;
    _imageSavePeriodSeconds = 1.0f / ImageSaveFrequencyHz;
  }

  private void Update() {
    // Rendering and saving images
    if ((DateTime.Now - _lastSaveTime).TotalSeconds >= _imageSavePeriodSeconds) {
      _cam.Render();
      // Color image
      RenderTexture.active = _colorRenderTexture;
      _colorSnapshotTexture.ReadPixels(new Rect(0, 0, _imageWidth, _imageHeight), 0, 0);
      string savePath = ImageSavePath + "/color_" + _saveCount;
      Texture2DToJpg(savePath, _colorSnapshotTexture);

      // Saving raw depth data as an image since issue seems to be with this.
      // Actual compute shader depth processing is not included.
      RenderTexture.active = _depthRenderTexture;
      _depthSnapshotTexture.ReadPixels(new Rect(0, 0, _imageWidth, _imageHeight), 0, 0);
      savePath  = ImageSavePath + "/depth_" + _saveCount;
      Texture2DToJpg(savePath, _depthSnapshotTexture);

      _saveCount++;
      _lastSaveTime = DateTime.Now;
    }
  }

  private void Texture2DToJpg(string fileSavePath, Texture2D imageTexture)
  {
    byte[] bytes;
    bytes = imageTexture.EncodeToJPG();
    File.WriteAllBytes(fileSavePath, bytes);
    bytes = null; //emptying array
  }
}
